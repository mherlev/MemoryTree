-- mem_if_ddr3_emif_0_example_design_example_sim_e0_d0.vhd

-- This file was auto-generated from altera_avalon_mm_traffic_generator_hw.tcl.  If you edit it your changes
-- will probably be lost.
-- 
-- Generated using ACDS version 14.0 200 at 2016.05.21.21:51:07

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity mem_if_ddr3_emif_0_example_design_example_sim_e0_d0 is
	generic (
		DEVICE_FAMILY                          : string  := "Stratix V";
		TG_AVL_DATA_WIDTH                      : integer := 512;
		TG_AVL_ADDR_WIDTH                      : integer := 30;
		TG_AVL_WORD_ADDR_WIDTH                 : integer := 24;
		TG_AVL_SIZE_WIDTH                      : integer := 1;
		TG_AVL_BE_WIDTH                        : integer := 64;
		DRIVER_SIGNATURE                       : integer := 1431634060;
		TG_GEN_BYTE_ADDR                       : boolean := true;
		TG_NUM_DRIVER_LOOP                     : integer := 1;
		TG_ENABLE_UNIX_ID                      : boolean := false;
		TG_USE_UNIX_ID                         : integer := 0;
		TG_RANDOM_BYTE_ENABLE                  : boolean := true;
		TG_ENABLE_READ_COMPARE                 : boolean := true;
		TG_POWER_OF_TWO_BURSTS_ONLY            : boolean := false;
		TG_BURST_ON_BURST_BOUNDARY             : boolean := false;
		TG_DO_NOT_CROSS_4KB_BOUNDARY           : boolean := false;
		TG_TIMEOUT_COUNTER_WIDTH               : integer := 32;
		TG_MAX_READ_LATENCY                    : integer := 20;
		TG_SINGLE_RW_SEQ_ADDR_COUNT            : integer := 32;
		TG_SINGLE_RW_RAND_ADDR_COUNT           : integer := 32;
		TG_SINGLE_RW_RAND_SEQ_ADDR_COUNT       : integer := 32;
		TG_BLOCK_RW_SEQ_ADDR_COUNT             : integer := 8;
		TG_BLOCK_RW_RAND_ADDR_COUNT            : integer := 8;
		TG_BLOCK_RW_RAND_SEQ_ADDR_COUNT        : integer := 8;
		TG_BLOCK_RW_BLOCK_SIZE                 : integer := 8;
		TG_TEMPLATE_STAGE_COUNT                : integer := 4;
		TG_SEQ_ADDR_GEN_MIN_BURSTCOUNT         : integer := 1;
		TG_SEQ_ADDR_GEN_MAX_BURSTCOUNT         : integer := 1;
		TG_RAND_ADDR_GEN_MIN_BURSTCOUNT        : integer := 1;
		TG_RAND_ADDR_GEN_MAX_BURSTCOUNT        : integer := 1;
		TG_RAND_SEQ_ADDR_GEN_MIN_BURSTCOUNT    : integer := 1;
		TG_RAND_SEQ_ADDR_GEN_MAX_BURSTCOUNT    : integer := 1;
		TG_RAND_SEQ_ADDR_GEN_RAND_ADDR_PERCENT : integer := 50
	);
	port (
		clk             : in  std_logic                      := '0';             -- avl_clock.clk
		reset_n         : in  std_logic                      := '0';             -- avl_reset.reset_n
		pass            : out std_logic;                                         --    status.pass
		fail            : out std_logic;                                         --          .fail
		test_complete   : out std_logic;                                         --          .test_complete
		avl_ready       : in  std_logic                      := '0';             --       avl.waitrequest_n
		avl_addr        : out std_logic_vector(29 downto 0);                     --          .address
		avl_size        : out std_logic;                                         --          .burstcount
		avl_wdata       : out std_logic_vector(511 downto 0);                    --          .writedata
		avl_rdata       : in  std_logic_vector(511 downto 0) := (others => '0'); --          .readdata
		avl_write_req   : out std_logic;                                         --          .write
		avl_read_req    : out std_logic;                                         --          .read
		avl_rdata_valid : in  std_logic                      := '0';             --          .readdatavalid
		avl_be          : out std_logic_vector(63 downto 0);                     --          .byteenable
		avl_burstbegin  : out std_logic                                          --          .beginbursttransfer
	);
end entity mem_if_ddr3_emif_0_example_design_example_sim_e0_d0;

architecture rtl of mem_if_ddr3_emif_0_example_design_example_sim_e0_d0 is
	component driver_avl_use_be_avl_use_burstbegin is
		generic (
			DEVICE_FAMILY                          : string  := "";
			TG_AVL_DATA_WIDTH                      : integer := 32;
			TG_AVL_ADDR_WIDTH                      : integer := 25;
			TG_AVL_WORD_ADDR_WIDTH                 : integer := 25;
			TG_AVL_SIZE_WIDTH                      : integer := 2;
			TG_AVL_BE_WIDTH                        : integer := 2;
			DRIVER_SIGNATURE                       : integer := 0;
			TG_GEN_BYTE_ADDR                       : boolean := true;
			TG_NUM_DRIVER_LOOP                     : integer := 1000;
			TG_ENABLE_UNIX_ID                      : boolean := false;
			TG_USE_UNIX_ID                         : integer := 0;
			TG_RANDOM_BYTE_ENABLE                  : boolean := false;
			TG_ENABLE_READ_COMPARE                 : boolean := true;
			TG_POWER_OF_TWO_BURSTS_ONLY            : boolean := false;
			TG_BURST_ON_BURST_BOUNDARY             : boolean := false;
			TG_DO_NOT_CROSS_4KB_BOUNDARY           : boolean := false;
			TG_TIMEOUT_COUNTER_WIDTH               : integer := 32;
			TG_MAX_READ_LATENCY                    : integer := 20;
			TG_SINGLE_RW_SEQ_ADDR_COUNT            : integer := 32;
			TG_SINGLE_RW_RAND_ADDR_COUNT           : integer := 32;
			TG_SINGLE_RW_RAND_SEQ_ADDR_COUNT       : integer := 32;
			TG_BLOCK_RW_SEQ_ADDR_COUNT             : integer := 8;
			TG_BLOCK_RW_RAND_ADDR_COUNT            : integer := 8;
			TG_BLOCK_RW_RAND_SEQ_ADDR_COUNT        : integer := 8;
			TG_BLOCK_RW_BLOCK_SIZE                 : integer := 8;
			TG_TEMPLATE_STAGE_COUNT                : integer := 4;
			TG_SEQ_ADDR_GEN_MIN_BURSTCOUNT         : integer := 1;
			TG_SEQ_ADDR_GEN_MAX_BURSTCOUNT         : integer := 2;
			TG_RAND_ADDR_GEN_MIN_BURSTCOUNT        : integer := 1;
			TG_RAND_ADDR_GEN_MAX_BURSTCOUNT        : integer := 2;
			TG_RAND_SEQ_ADDR_GEN_MIN_BURSTCOUNT    : integer := 1;
			TG_RAND_SEQ_ADDR_GEN_MAX_BURSTCOUNT    : integer := 2;
			TG_RAND_SEQ_ADDR_GEN_RAND_ADDR_PERCENT : integer := 50
		);
		port (
			pass                : out std_logic;                                         -- pass
			fail                : out std_logic;                                         -- fail
			test_complete       : out std_logic;                                         -- test_complete
			clk                 : in  std_logic                      := 'X';             -- clk
			reset_n             : in  std_logic                      := 'X';             -- reset_n
			avl_ready           : in  std_logic                      := 'X';             -- waitrequest_n
			avl_addr            : out std_logic_vector(29 downto 0);                     -- address
			avl_size            : out std_logic;                                         -- burstcount
			avl_wdata           : out std_logic_vector(511 downto 0);                    -- writedata
			avl_rdata           : in  std_logic_vector(511 downto 0) := (others => 'X'); -- readdata
			avl_write_req       : out std_logic;                                         -- write
			avl_read_req        : out std_logic;                                         -- read
			avl_rdata_valid     : in  std_logic                      := 'X';             -- readdatavalid
			avl_be              : out std_logic_vector(63 downto 0);                     -- byteenable
			avl_burstbegin      : out std_logic;                                         -- beginbursttransfer
			pnf_per_bit         : out std_logic_vector(511 downto 0);                    -- pnf_per_bit
			pnf_per_bit_persist : out std_logic_vector(511 downto 0);                    -- pnf_per_bit_persist
			csr_address         : in  std_logic_vector(12 downto 0)  := (others => 'X'); -- address
			csr_write           : in  std_logic                      := 'X';             -- write
			csr_writedata       : in  std_logic_vector(31 downto 0)  := (others => 'X'); -- writedata
			csr_read            : in  std_logic                      := 'X';             -- read
			csr_readdata        : out std_logic_vector(31 downto 0);                     -- readdata
			csr_waitrequest     : out std_logic;                                         -- waitrequest
			csr_be              : in  std_logic_vector(3 downto 0)   := (others => 'X')  -- byteenable
		);
	end component driver_avl_use_be_avl_use_burstbegin;

begin

	device_family_check : if DEVICE_FAMILY /= "Stratix V" generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_avl_data_width_check : if TG_AVL_DATA_WIDTH /= 512 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_avl_addr_width_check : if TG_AVL_ADDR_WIDTH /= 30 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_avl_word_addr_width_check : if TG_AVL_WORD_ADDR_WIDTH /= 24 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_avl_size_width_check : if TG_AVL_SIZE_WIDTH /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_avl_be_width_check : if TG_AVL_BE_WIDTH /= 64 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	driver_signature_check : if DRIVER_SIGNATURE /= 1431634060 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_gen_byte_addr_check : if TG_GEN_BYTE_ADDR /= true generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_num_driver_loop_check : if TG_NUM_DRIVER_LOOP /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_enable_unix_id_check : if TG_ENABLE_UNIX_ID /= false generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_use_unix_id_check : if TG_USE_UNIX_ID /= 0 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_random_byte_enable_check : if TG_RANDOM_BYTE_ENABLE /= true generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_enable_read_compare_check : if TG_ENABLE_READ_COMPARE /= true generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_power_of_two_bursts_only_check : if TG_POWER_OF_TWO_BURSTS_ONLY /= false generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_burst_on_burst_boundary_check : if TG_BURST_ON_BURST_BOUNDARY /= false generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_do_not_cross_4kb_boundary_check : if TG_DO_NOT_CROSS_4KB_BOUNDARY /= false generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_timeout_counter_width_check : if TG_TIMEOUT_COUNTER_WIDTH /= 32 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_max_read_latency_check : if TG_MAX_READ_LATENCY /= 20 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_single_rw_seq_addr_count_check : if TG_SINGLE_RW_SEQ_ADDR_COUNT /= 32 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_single_rw_rand_addr_count_check : if TG_SINGLE_RW_RAND_ADDR_COUNT /= 32 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_single_rw_rand_seq_addr_count_check : if TG_SINGLE_RW_RAND_SEQ_ADDR_COUNT /= 32 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_block_rw_seq_addr_count_check : if TG_BLOCK_RW_SEQ_ADDR_COUNT /= 8 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_block_rw_rand_addr_count_check : if TG_BLOCK_RW_RAND_ADDR_COUNT /= 8 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_block_rw_rand_seq_addr_count_check : if TG_BLOCK_RW_RAND_SEQ_ADDR_COUNT /= 8 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_block_rw_block_size_check : if TG_BLOCK_RW_BLOCK_SIZE /= 8 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_template_stage_count_check : if TG_TEMPLATE_STAGE_COUNT /= 4 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_seq_addr_gen_min_burstcount_check : if TG_SEQ_ADDR_GEN_MIN_BURSTCOUNT /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_seq_addr_gen_max_burstcount_check : if TG_SEQ_ADDR_GEN_MAX_BURSTCOUNT /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_rand_addr_gen_min_burstcount_check : if TG_RAND_ADDR_GEN_MIN_BURSTCOUNT /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_rand_addr_gen_max_burstcount_check : if TG_RAND_ADDR_GEN_MAX_BURSTCOUNT /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_rand_seq_addr_gen_min_burstcount_check : if TG_RAND_SEQ_ADDR_GEN_MIN_BURSTCOUNT /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_rand_seq_addr_gen_max_burstcount_check : if TG_RAND_SEQ_ADDR_GEN_MAX_BURSTCOUNT /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	tg_rand_seq_addr_gen_rand_addr_percent_check : if TG_RAND_SEQ_ADDR_GEN_RAND_ADDR_PERCENT /= 50 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	traffic_generator_0 : component driver_avl_use_be_avl_use_burstbegin
		generic map (
			DEVICE_FAMILY                          => "Stratix V",
			TG_AVL_DATA_WIDTH                      => 512,
			TG_AVL_ADDR_WIDTH                      => 30,
			TG_AVL_WORD_ADDR_WIDTH                 => 24,
			TG_AVL_SIZE_WIDTH                      => 1,
			TG_AVL_BE_WIDTH                        => 64,
			DRIVER_SIGNATURE                       => 1431634060,
			TG_GEN_BYTE_ADDR                       => true,
			TG_NUM_DRIVER_LOOP                     => 1,
			TG_ENABLE_UNIX_ID                      => false,
			TG_USE_UNIX_ID                         => 0,
			TG_RANDOM_BYTE_ENABLE                  => true,
			TG_ENABLE_READ_COMPARE                 => true,
			TG_POWER_OF_TWO_BURSTS_ONLY            => false,
			TG_BURST_ON_BURST_BOUNDARY             => false,
			TG_DO_NOT_CROSS_4KB_BOUNDARY           => false,
			TG_TIMEOUT_COUNTER_WIDTH               => 32,
			TG_MAX_READ_LATENCY                    => 20,
			TG_SINGLE_RW_SEQ_ADDR_COUNT            => 32,
			TG_SINGLE_RW_RAND_ADDR_COUNT           => 32,
			TG_SINGLE_RW_RAND_SEQ_ADDR_COUNT       => 32,
			TG_BLOCK_RW_SEQ_ADDR_COUNT             => 8,
			TG_BLOCK_RW_RAND_ADDR_COUNT            => 8,
			TG_BLOCK_RW_RAND_SEQ_ADDR_COUNT        => 8,
			TG_BLOCK_RW_BLOCK_SIZE                 => 8,
			TG_TEMPLATE_STAGE_COUNT                => 4,
			TG_SEQ_ADDR_GEN_MIN_BURSTCOUNT         => 1,
			TG_SEQ_ADDR_GEN_MAX_BURSTCOUNT         => 1,
			TG_RAND_ADDR_GEN_MIN_BURSTCOUNT        => 1,
			TG_RAND_ADDR_GEN_MAX_BURSTCOUNT        => 1,
			TG_RAND_SEQ_ADDR_GEN_MIN_BURSTCOUNT    => 1,
			TG_RAND_SEQ_ADDR_GEN_MAX_BURSTCOUNT    => 1,
			TG_RAND_SEQ_ADDR_GEN_RAND_ADDR_PERCENT => 50
		)
		port map (
			pass                => pass,                               --    status.pass
			fail                => fail,                               --          .fail
			test_complete       => test_complete,                      --          .test_complete
			clk                 => clk,                                -- avl_clock.clk
			reset_n             => reset_n,                            -- avl_reset.reset_n
			avl_ready           => avl_ready,                          --       avl.waitrequest_n
			avl_addr            => avl_addr,                           --          .address
			avl_size            => avl_size,                           --          .burstcount
			avl_wdata           => avl_wdata,                          --          .writedata
			avl_rdata           => avl_rdata,                          --          .readdata
			avl_write_req       => avl_write_req,                      --          .write
			avl_read_req        => avl_read_req,                       --          .read
			avl_rdata_valid     => avl_rdata_valid,                    --          .readdatavalid
			avl_be              => avl_be,                             --          .byteenable
			avl_burstbegin      => avl_burstbegin,                     --          .beginbursttransfer
			pnf_per_bit         => open,                               -- (terminated)
			pnf_per_bit_persist => open,                               -- (terminated)
			csr_address         => "0000000000000",                    -- (terminated)
			csr_write           => '0',                                -- (terminated)
			csr_writedata       => "00000000000000000000000000000000", -- (terminated)
			csr_read            => '0',                                -- (terminated)
			csr_readdata        => open,                               -- (terminated)
			csr_waitrequest     => open,                               -- (terminated)
			csr_be              => "0000"                              -- (terminated)
		);

end architecture rtl; -- of mem_if_ddr3_emif_0_example_design_example_sim_e0_d0
